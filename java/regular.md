#java 正则表达式
##正则匹配中的转义字符：[] {} \ + . * ? 
如果在其他语言中使用过正则表达式，你就会发现java对反斜线\的不同处理。在其他语言中,\\表示要在正则表达式中插入一个普通的反斜线，没有任何特殊的意义，
而在java中，\\的意思是：我要插入一个正则表达式的反斜线，其后存在的字符具有特殊的意义。<br>
例如：表示一位数字java正则表达式为：\\d, 表示一个普通的反斜线，则应该这样\\\\。<br>
如果你只是想匹配[]{} 这样的字符没有任何特殊的意义那么你应该在这些字符的前面加\\来转义这些特殊字符，加\\的含义就是他们只是普通的字符，没有任何的特殊意义。<br>
####[] 的意义
这两个字符通常和a-zA-Z0-9搭配使用。<br>
* [a-cA-Z] : 从a-z或A-Z之间的任意字符
* \d :  从0到9的任意数字
* \D : 非数字（[^0-9]）
* {4} : 前一表达式的匹配数目为4个
* \s：空白符（空格，tab,换行，换页，回车）
* \S：非空白符
* \w：词字符（[a-zA-Z0-9]）
* \W：非词字符

##常用到的匹配符：+ . * ?
（1）. + 号的作用是表示一个或多个之前的表达式，一般以前一个（）做为标志，如果之前没有（）则寻找最近的通配字符。
例：（[a-z]\\d）+ 和[a-z]\\d+的效果完全不一样。前者匹配的时候可以有多个[a-z]\\d,后者匹配则表示有多个\\d。
（2） .  号的作用是匹配任意字符。例：（.）的匹配表示匹配任何字符。
（3）. * 号的作用是匹配任意长度。
（4）. ? 号的作用表示可能有0个或1个之前的表达式。例：-？则表示可能有1个负号。

###正则匹配的量词：贪婪型，占有型，勉强型
贪婪型是尽可能多的匹配，勉强型是匹配满足模式所需的最少字数。占有型是java中特有的，其他语言看不到，它常常用于防止正则表达式失控。<br>
目前我用到的只有一个关于贪婪型和勉强型的例子。<br>
```java
String  testStr = "[v1]{signature_key[543DE]}[v2]{signature_key:[543DE]}";
Matcher mMatcher = Pattern.compile("("(\\[v\\d)(\\])(.*)(\\]\\});
```
上面的形式就是贪婪匹配，这样匹配表达的意思是以 [v] 开始匹配，以]} 结束如上所示匹配的结果是整个字符串，
而我们需要的结果是两个字符串"[v1]{signature_key[543DE]}和[v2]{signature_key:[543DE]}<br>
```java
Matcher mMatcher = Pattern.compile("("(\\[v\\d)(\\])(.*?)(\\]\\});
```
这样匹配的结果就是"[v1]{signature_key[543DE]}，[v2]{signature_key:[543DE]}。其中意味只能自己体会。
* X?：一个或零个X
* X+：一个或多个X
* X*：零个或多个X
* X{n}：恰好n次
* X{n,}：至少n次
* X{n,m}：至少n次，至多M次

###Pattern 和 Matcher类的使用
Pattern和Matcher类的配合使用可以使正则表达式的解析轻松许多。
```java
Matcher mMatcher = Pattern.compile("A(B(C))D");
while (mMatcher.find()){
     mMatcher.group();
}
```
1. group是组的意思，组是用括号划分的正则表达式。如上面组号0表示整个表达式，组号1表示BC ,组号2是C。相应的我们要得到他们的值可以采用:
mMatcher.group(0);mMatcher.group(1);mMatcher.group(2);这样的形式来得到想要的结果。
2. split 字符串分割，replace字符串代替
